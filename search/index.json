[{"content":"IDEA乱码问题（亲测有效） 强行配置UTF-8\r1.ctrl+alt+s进入设置，改变全局编码 UTF-8\n2.配置Tomcat VM options值为：-Dfile.encoding=UTF-8\n3.在tomcat启动配置 JAVA_OPTS =-Dfile.encoding=UTF-8\n4.进入help的虚拟机参数配置（VM OPTIONS）配置-Dfile.encoding=UTF-8\n5.进入IDEA安装根目录 编辑idea.exe.vmoptions与idea64.exe.vmoptions，都加上-Dfile.encoding=UTF-8\n6.在你本机的tomcat目录下 在conf中找到logging.properties 更改配置如下图。如果有该配置 则不添加\n7.检查右下角控制台编码是否为UTF-8 ，如果不是， 则更改。\n重启IDEA 在运行 控制台乱码问题就解决啦 嘿嘿.\n配置JDK的javac命令输出英文信息\r方法一\r在配置IntelliJ IDEA等IDE后，虽然IDE操作界面的语言是英文的，但是由于电脑的环境语言是中文的，所以在IDE操作JDK的java或javac命令，JDK还是按照电脑的环境语言配置而输出中文的提示信息、报错信息等。\n我们更希望JDK的输出信息是英文版的，因为这样避免了英译中潜在的歧义，同时我们也可以通过英文的输出信息在Google查询到更详细和权威的解决方案。\n通过百度，可以查询到类似的解决方案，例如这篇文章《IntelliJ IDEA 编译输出改为英文 运行信息改为英文》分别介绍了Windows环境变量配置、IDEA编译器参数配置、VM配置文件参数配置。\n由于Windows环境变量配置的方法只适用于Windows电脑，因此其有效性暂不做评论。但是博主亲自测试上述文章中IDEA编译器参数配置的方案是没有生效的，即JDK的输出信息是中文内容。\n因此博主又去查询了其他的配置方法，发现这篇文章*《How to set intellij compile error output language to English?》*中提供的方案是有效的，同时也是上篇文章中的最后一个方案，即VM配置文件参数配置方案。\nVM配置文件参数配置方案 我们首先打开IntelliJ IDEA这款软件，然后在其标题栏中找到并点击Help标签，接着点击该标签中的子项Edit Custom VM Options：\n接着我们便进入了idea.vmoptions配置文件的编辑界面，我们只需在该文件的最后一行加入一个选项参数-Duser.language=en即可：\n编辑好上述的idea.vmoptions配置文件后，还有最后一步重要的操作，也就是重启IntelliJ IDEA，因为只有重启后上述配置信息才会生效。注意重启IntelliJ IDEA不是关闭当前IntelliJ IDEA的项目窗口，而是杀死IntelliJ IDEA的进程，最方便的操作就是对正在运行的IntelliJ IDEA点击鼠标右键，再点击关闭或退出选项即可(无论Windows或Mac)：\n重启IntelliJ IDEA后，我们再通过编译运行任意会产生编译信息的项目，发现现在的JDK的输出信息是英文内容了：\n方法二\r一。增加环境变量 JAVA_TOOL_OPTIONS ，值为 -Duser.language=en\n","date":"2024-09-09T20:50:53+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/jdk/","title":"JDK强制英文运行"},{"content":"计算机组成与体系结构\r1内容提要\r课程内容提要\r数据的表示\n计算机结构\nFlynn分类法\nCISC与RISC\n流水线技术\n存储系统\n总线系统\n可靠性\n校验码\n2数据的表示\r2.1 进制转换\r2.1.1 R进制转十进制\rR进制转十进制使用按权展开法，其具体操作方式为：将R进制数的每一位数值用Rk形式表示，即幂的底数是R，指数为k，k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间数码的个数加1。\n例如二进制10100.01＝1x24＋1x22＋1x2-2\n例如七进制60 01＝6x72＋0x71＋4x70＋0x7-1\n2.1.2十进制转R进制\r十进制转R进制使用短除法。例如将94转换为二进制数。\n得到结果为1011110\n余 2 94 0 2 47 1 2 23 1 2 11 1 2 5 1 2 2 0 2 1 2.1.3其他进制转换\r二进制转八进制，从右到左，每三位是和是一个八进制的值\n二进制转十六进制，从右到左，每四位是和是一个十六进制的值\n其中A=10 B=11 C=12 D=13 E=14 F=15\n二进制转八进制与十六进制数。\n10 001 110 2 1 6 1000 1100 8 E 2.2 原码、反码、补码、移码、浮点运算\r正数的原码、反码、补码相同\n负数\n原码：首位是1\n反码：除首位，其他位按位取反\n补码：反码基础上加1\n移码：正数负数首位取反（用于在浮点运算中的接码？）\n数值1 数值-1 1-1 原码 0000 0001 1000 0001 1000 0010 反码 0000 0001 1111 1110 1111 1111 补码 0000 0001 1111 1111 0000 0000 移码 1000 0001 0111 1111 1000 0000 表示范围\n整数 原码 -(2n-1-1)~2n-1-1 反码 -(2n-1-1)~2n-1-1 补码 -2n-1~2n-1-1 2.3浮点数运算\r浮点数最终要求结果为：y.xxx*10^n次方表示(0\u0026lt;y\u0026lt;10)y不允许是两位数\n浮点数表示:\nN=M*R\n其中M称为尾数，e是指数，R为基数。\n对阶$\\Rightarrow$尾数计算$\\Rightarrow$结果格式化\n3计算机结构\r主机：主存储器，CPU\nCPU：\n运算器 控制器 运算器：\n算术逻辑单元ALU 累加寄存器AC 数据缓冲寄存器DR 状态条件寄存器PSW 控制器：\n指令寄存器IR 程序计数器PC 指令译码器 时序部件 CPU寄存器划分、运算器、控制器区分，常见寄存器特性\n3.1结构分类Flynn\r掌握特性和代表\n计算机体系结构分类-Flynn\n体系结构类型 结构 关键特性 代表 单指令流单数据流SISD 控制部分：一个 处理器：一个 主存模块：一个 单处理器系统 单指令流多数据流SIMD 控制部分：一个 处理器：多个 主存模块：多个 各处理器以异步的形式执行同一条指令 并行处理机阵列处理机超级向量处理机 多指令流单数据流MISD 控制部分：多个 处理器：一个 主存模块：多个 被证明不可能，至少是不实际 目前没有，有文献称流水线计算机为此类 多指令流多数据流MIMD 控制部分：多个 处理器：多个 主存模块：多个 能够实现作业、任务、指令等各级全面并行 多处理机系统多计算机 4 CISC与RISC计算机指令特点\r区别\n指令系统类型 指令 寻址方式 实现方式 其它 CISC（复杂） 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术（微码） 研制周期长 RISC（精简） 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主：适合采用流水线 优化编译，有效支持高级语言 5流水线：考察计算问题\r5.1概念\r流水线-概念流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的 不同部分进行工作，以提高各部件的利用率和指令的平均执行速度\n使用流水线执行指令情况\n未使用流水线执行指令情况\n取指 1 2 3 分析 1 2 3 执行 1 2 3 使用流水线执行指令情况\n取指 1 2 3 分析 1 2 3 执行 1 2 3 5.2计算\rk为阶段数\n5.2.1 周期、总时长\r取指 1 2 3 . . . n 分析 1 2 3 . . . n 执行 1 2 3 . . . n 流水线周期为执行时间最长的一段\n流水线计算公式为：\n1条指令执行时间+（指令条数-1）*流水线周期\n①理论公式:(t1+t2+\u0026hellip;+tk)+(n-1)*∆t\n②实践公式:(k+n-)*∆t\n例：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别 是取指2nsl分析2ns，执行1ns。那么，流水线周期是多少？100条指令全部执行完毕需要的时间是多少？\n5.2.2吞吐率\r流水线-流水线吞吐率计算\n流水线的吞吐率（Though Put rate，TP）是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的最基本的公式如下：\n$TP=\\frac{指令条数}{流水线执行时间}$\n流水线最大吞吐率：\n$TP_{\\max}=Lim_{n\\rightarrow\\infty}\\frac{n}{(k+n-1)∆t}=\\frac{1}{∆t}$\n5.2.3加速比\r流水线-流水线的加速比\n完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。计算流水线加速比的基本公式如下：\n$S=\\frac{不使用流水线执行时间}{使用流水线执行时间}$\n5.2.4效率（这个不理解）\r流水线的效率是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比\n计算流水线效率的公式为：\n$E = \\frac { n 个 任 务 占 用 的 时 空 区 } { k 个 流 水 段 的 总 的 时 空 区 } = \\frac { T _ { 0 } } { k T _ { k } }$\n6存储系统：概念、计算\r6.1层次化存储结构\rcache按内容存取的也叫相连存储器\n层次化存储结构\n快 CPU 寄存器 Cache 按内容存取 速度 内存（主存） 慢 外存\n快 CPU 寄存器 Cache 按内容存取 内存(主存) 慢 外存(辅存) 硬盘、光盘、U盘等 6.2 Cache概念\rCache-概念\nCache的功能：提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。\n在计算机的存储系统体系中，Cache是访问速度最快的层次。\n使用Cache改善系统性能的依据是程序的局部性原理。\n如果以h代表对Cache的访问命中率，t_{1}表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“Cache＋主存储器”的系统的平均周期为$t_{3},$则：\n$t_{3}=h*t_{1}+(1-h)*t_{2}$\n其中，（1-h）又称为失效率（未命中率）。\neg: 1nsx95%+100nsx(1-95%)=19.5ns\n6.3局部性原理\r时间局部性：刚刚访问完后又访问，如循环体内的命令\n空间局部性：数组，相邻的空间可能也会被访问\n时间局部性\n空间局部性\n工作集理论：工作集是进程运行时被频繁访问的页面集合\n例：\n1 2 3 4 5 int i,s=0; for(i=1:i\u0026lt;1000:i++) for(j=1:j\u0026lt;1000:j++) s+=j; printf（＂结果为：％d”，s） 6.4主存分类\r主存的编址考察比较多\nRAM：掉电后不会存储信息\nROM：掉电后仍然存储信息\n主存-分类\n随机存取存储器（RAM）：\nDRAM（Dynamic RAM，动态RAM）-SDRAM SRAM （Static RAM，静态） 只读存储器：\nMROM（Mask ROM，掩模式ROM） PROM （Programmable ROM，一次可编程 ROM） EPROM（Erasable PROM，可擦除的 PROM） 闪速存储器（flash memory，闪存） 6. 1主存编址\r8＊4位的存储器\n8＊8位的存储器 28x1 164位的存储器\n内存地址从AC000H到C7FFFH，共有（112）K个地址单元，如果该内存地址按字（16bit）编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每 个存储单元存储（4） 位。 (1)A.96 B.112 (2)A.4 B.8\n6.5磁盘（现在考察没有以前多了，理解原理，做什么动作，需要多少时间）没理解例题\r磁盘结构与参数\n磁道 扇区\n存取时间＝寻道时间＋等待时间（平均定位时间＋转动延迟）\n注意：寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁 头下方所用的时间。\n试题\n物理块 1 2 3 4 5 6 7 8 9 10 11 逻辑记录 R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R0， R1,\u0026hellip;,R9,R10存放在同一个磁道上，记录的存放顺序如下表所示：\n如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处。若系统使用单缓冲区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为（48 C）；若对信息 存储进行优化分布后，处理11个记录的最少时间为（49 B）。 (48)A.33ms B.336ms C.366ms D.376ms (49)A.33ms B 66ms c.86ms D.93ms\n7 总线系统：总线分类和概念\r总线\n根据总线所处的位置不同，总线通常被分成三种类型，分别是：\n内部总线\n系统总线\n数据总线 地址总线 控制总线 外部总线\n8可靠性分析：串联、并联计算、混合情况\rR为可靠度\n串联\n$R=R_{1}R_{2}\u0026hellip;*R_{n}$\n$\\lambda=\\lambda_{1}+\\lambda_{2}+\\cdots+\\lambda_{n}$\n并联\nu为失效率＝1-可靠度来计算\n$R=1-(1-R_{1})\\times(1-R_{2})\\times\\cdots\\times(1-R_{n})$\n$\\mu=\\frac{1}{\\frac{1}{\\lambda}\\sum_{j=1}^{n}\\frac{1}{j}}$\n混合\n$R=R\\times(1-(1-R)^3)\\times(1-(1-R)^2)$\n9校验码：作用、常见校验码：CRC、海明校验码 特点，计算过程、编码解码\r9.1码距\r什么是码距？\n一个编码系统的码距是整个编码系统中任意（所有）两个码字的最小距离。\n例\n若用1位长度的二进制编码。若$A=1,$B＝0。这样A，B之间的最小码距为1。\n若用2位长度的二进制编码，若以A＝11，$B=00$为例，A、B之间的最小码距为2。\n若用3位长度的二进制编码，可选用111,000作为合法编码。A，B之间的最小码距为3。\n9.2检错、纠错\r码距与检错、纠错有何关系？\n1．在一个码组内为了检测e个误码，要求最小码距d应该满足： d\u0026gt;=e+1\n2．在一个码组内为了纠正t个误码，要求最小码距d应该满足： d\u0026gt;=2t+1\n9.3循环校验码CRC检错，不能纠错\r异或：相同0，不同为1\n什么是模2除法，它和普通的除法有何区别？\n模2除法是指在做除法运算的过程中不计其进位的除法。\n例如，10111对110进行模2除法为：\n1 1 0 110 1 0 1 1 1 1 1 0 0 1 1 1 1 1 0 \u003c\u003e 0 0 1 1 例子：\n校验码-循环校验码CRC\n例：原始报文为“11001010101”，其生成多项式为：$x^4+x^3+x+1$。对其进行CRC编码后的结果为？\n解：11001010101除以11011后得到余数为0011，所以CRC编码后的结果为：110010101010011。\n9.4海明校验码\r校验位在2＾n位\n校验位和信息为关系满足：$2^r\u0026gt;=x+r+1$ （r为校验信息位，x为信息）\n例子\n例：求信息1011的海明码。\n(1)$2^{r}\u0026gt;=4+r+1$，确定校验码为3位：$2^{3}\u0026gt;=4+3+1$。分别放在$2^{0}=1$、$2^{1}=2$、$2^{2}=4$位。\n7 6 5 4 3 2 1 位数 I4 I3 I2 I1 信息位 r2 r1 r0 校验位 （2）列出校验位公式。\n$7=2^{2}+2^{1}+2^{0}$, $6=2^{2}+2^{1}$, $5=2^{2}+2^{0}$, $3=2^{1}+2^{0}$;\n$r_{2}=I_{4}⊕I_{3}⊕I_{2}$, $r_{1}=I_{4}⊕I_{3}⊕I_{1}$, $r_{0}=I_{4}⊕I_{2}⊕I_{1}$.\n（3）根据公式得 $r_{ 2 } = 0 , r_{ 1 } = 0 , r_{0}=1$。\n（4）将数据加入表格，如表所示。\n若收到的信息为：1011101 则：\n$r_{2}⊕I_{4}⊕I_{3}⊕I_{2}$=1⊕1⊕0⊕1=1, $r_{1}⊕I_{4}⊕I_{3}⊕I_{1}$=0⊕1⊕0⊕1=0, $r_{0}⊕I_{4}⊕I_{2}⊕I_{1}$=1⊕1⊕1⊕1=0.\n","date":"2024-09-07T20:31:39+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E8%BD%AF%E8%80%83/","title":"计算机组成与体系结构"},{"content":"查看所有端口占用情况：\rwin+R，调出cmd窗口：\n查看所有端口占用情况：\rnetstat -ano\n查看指定端口占用情况（端口引号有没有都可以，此处以5040为例）：\rnetstat -aon|findstr 5040\nor\nnetstat -aon|findstr \u0026quot;5040\u0026quot;\n记住最后一列数字PID，此处为5340。\n根据PID查看相应的进程或程序：\r（1）、命令行查看：\ntasklist|findstr 5340\n查看到该PID对应的程序为svchost.exe\n（2）、任务管理器查看：\n快捷键Ctrl+Alt+Delete，打开任务管理器，可查看PID对应的进程：\n如果没有PID列：\n右键名称、状态标题行，选择PID：\n则PID列就出来了，可根据PID找到相应的进程：\n结束相应进程：\r（1）、命令行：\ntaskkill /f /t /im 进程名 承上如：\ntaskkill /f /t /im svchost.exe\n（2）、任务管理器中结束进程：\n","date":"2024-09-04T13:25:00+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E7%AB%AF%E5%8F%A3/","title":"Windows_查看端口被占用情况、结束进程"},{"content":"JSP 简单入门与 IDEA 开发环境配置\n在学 Java 连接数据库时老师提到过 JSP，刚好这个学期有 JSP 的课程，现做一些基础以及环境配置的介绍。\n什么是 JSP？\r动态网页技术标准 能把 Java 代码嵌入静态的页面中 JSP 编译器把 JSP 文件编译成 Java 写的 Servlet(服务器端程序)，再交由 Java 编译器 1 2 3 4 5 6 \u0026lt;html\u0026gt; \u0026lt;title\u0026gt;Hello world!\u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%=out.println(\u0026#34;Hello world!\u0026#34;)%\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 环境配置\r语言环境：JDK 网页服务器：Tomcat，安装教程 IDE：IntelliJ IDEA / Eclipse 前两点非常简单不再赘述。\n老师竟然说 JSP 没什么好用的编辑器只能在 Eclipse 中写（黑人问号\n明明 IDEA 就很好\u0026hellip;.\n这里记录一下 IDEA 如何配置 JSP 的开发环境\nIntelliJ IDEA Configuration\r新建一个 Java Enterprise 项目，下面 Application Server 选择新建，\n选择 Tomcat Server，设置 Tomcat Home (安装目录)\n1 2 3 4 5 这里需要注意 IDEA 可能会没有权限访问 Tomcat 的目录，导致无法读取 Tomcat，需要手动访问一次该目录提权： * Windows：资源管理器直接访问，会提示需要管理员权限，点继续就 OK 了 * Linux：chmod 777 下面 Additional Libraries and Frameworks 选择 Web Application，\n点 Next，改名创建，得到如下图所示结构的项目\n打开 index.jsp\n打开右上角 Edit Configuration\n选择 Application server\nURL 一般是：http://localhost:8080/demo_war_exploded/\n其中 demo 为项目名字，_war_exploded 为自动生成的后缀，需要保留\n打开 Deployment，界面应如下图\n如果这个 war_exploded 没有出现在里面的话点击右边加号自己加进去\n简单写一下 index.jsp\n比如下面实现了一个简单的 Hello world 的页面\n1 2 3 4 5 6 \u0026lt;html\u0026gt; \u0026lt;title\u0026gt;Hello world!\u0026lt;/title\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%=out.println(\u0026#34;Hello world!\u0026#34;)%\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 点击右上角 Run，开始运行 update：21.9.22 切回至“Server”，在“Open Browser”设置里，\n建议勾选上“After Launch”，意思为当启动TomCat后，自动打开浏览器并运行项目，此时同样可以在别的浏览器手动输入地址进行访问。\n建议将“On 'Update' action”和“On frame deactivation”设置为“Update classes and resources”，这样当修改项目内容时会自动更新字节码文件和资源文件，避免反复重启TomCat服务器：\nQuestion \u0026amp; Solution\r运行之后会大概率出现以下问题，不要问我怎么知道的…\n端口超界，不能为 - 1 原因：Tomcat 安装的默认 Shutdown 端口为 - 1，需要修改一下\n解决：打开 Tomcat 安装目录下的 server.xml，类似如下路径\n1 C:\\Program Files\\apache-tomcat-8.5.71-windows-x64\\apache-tomcat-8.5.71\\conf\\server.xml 修改shutdown port为任一未被占用的端口 (1024 - 65535)，如8005位置\n端口 8080 已被占用 原因：Tomcat 运行中并占用了 8080 端口\n解决：打开刚才的 Edit Configuration，修改 Tomcat Server Settings 中的 HTTP port 为任一未被占用的端口 (1024 - 65535)，如”8088”，同时别忘修改上面的 URL 的端口\noutput 输出乱码 原因：Tomcat 根据你的操作系统默认语言使用了 GBK 编码\n解决：打开 Tomcat 安装目录下的 logging.properties，类似如下路径\n1 C:\\Program Files\\apache-tomcat-8.5.71-windows-x64\\apache-tomcat-8.5.71\\conf\\logging.properties 修改大约第 47 行的\n1 java.util.logging.ConsoleHandler.encoding = UTF-8 为\n1 java.util.logging.ConsoleHandler.encoding = GBK 打开网页 404 原因：URL 写错了，定位不到文件\n解决：Edit Configuration 中检查一下 URL 是否与端口设置一致，是否正确定位了文件路径\n输出一堆红色字 正常现象，开发者选色鬼才\n网页调试的方法 运行之后修改了代码，怎么才能重新看到修改后的网页呢？\n无需终止 Tomcat 重新运行，只需在左下这个位置点击 Deploy，然后刷新网页就可以啦\n如果没有问题此时应该可以正确运行啦，开始在 IDE 中愉快的写 JSP 吧（雾\n基本语法\r因为了解不深，详细的就不多说了。\n除了特别的这几个，其他的都和 HTML 与 Java 语法规则差不多。\n脚本\r1 2 3 \u0026lt;% //在这里编写你的Java代码 %\u0026gt; 任何文本、HTML 标签、JSP 元素必须写在脚本程序的外面\n声明\r1 2 3 \u0026lt;%! //Java %\u0026gt; 用于声明变量、方法，要写函数只能在这里面\n必须先声明才可以使用\n表达式\r1 \u0026lt;%= //Java %\u0026gt; 表达式里面的代码可以不写分号\n注释\r1 2 3 \u0026lt;%-- 该部分注释在网页中不会被显示 --%\u0026gt; \u0026lt;!-- 该部分注释在网页源代码中会被显示 --\u0026gt; 指令\r1 2 3 \u0026lt;%@ page 页面属性 %\u0026gt; \u0026lt;%@ include 包含文件 %\u0026gt; \u0026lt;%@ taglib 标签 %\u0026gt; 模板\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34; %\u0026gt; \u0026lt;!--导入的Java包--\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;网页标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%! //定义变量 %\u0026gt; \u0026lt;%! //定义函数 %\u0026gt; \u0026lt;% //脚本 %\u0026gt; \u0026lt;!-- 在这里定义其他网页上展示的组件 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 示例：计算 N 的阶乘\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Calc\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;\u0026#34;/\u0026gt; \u0026lt;h1\u0026gt; Calculate N! \u0026lt;/h1\u0026gt; \u0026lt;!--*.jsp--\u0026gt; \u0026lt;form action=\u0026#34;index.jsp\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;num\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;/\u0026gt;\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;form/\u0026gt; \u0026lt;%! private int n = -1; %\u0026gt; \u0026lt;%! public int fac(int n) { if (n \u0026lt; 0) { return n; } else if (n == 0) { return 1; } else { int product = 1; for (int i = 1; i \u0026lt;= n; i++) { product *= i; if (product \u0026lt; 0) { break; } } return product; } } %\u0026gt; \u0026lt;% try { int n = fac(Integer.parseInt(request.getParameter(\u0026#34;num\u0026#34;))); if (n \u0026lt; 0) { out.print(\u0026#34;\u0026lt;h2\u0026gt;invalid\u0026lt;/h2\u0026gt;\u0026#34;); } else { out.print(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34;+n+\u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;); } } catch (Exception e) { //ignore java.lang.NumberFormatException: null } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 示例：数据库查询系统\r依赖包：mysql-connector-java-5.1.*.jar 可能需要将 jar 包拷贝到项目路径下的 WEB-INF/lib 中（不存在就新建） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.sql.*\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Database Query System\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Database Query System\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;powered by bipy\u0026lt;/h2\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;textarea name=\u0026#34;SQL_statement\u0026#34; rows=10 cols=100\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;Submit\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; name=\u0026#34;Clear\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;%! private Statement statement; private String sql_input; private Connection connection; private boolean status = false; %\u0026gt; \u0026lt;%! //判断SQL语句类型，并返回结果（影响个数/报错/结果集） public Object process(String sql) { try { if (sql.toLowerCase().matches(\u0026#34;^(update|create|use|drop|delete|insert).*$\u0026#34;)) { return statement.executeUpdate(sql); } else if (sql.toLowerCase().matches(\u0026#34;^(show|select).*$\u0026#34;)) { return statement.executeQuery(sql); } else { return \u0026#34;Not Supported\u0026#34;; } } catch (SQLException e) { e.printStackTrace(); return \u0026#34;SQL syntax error\u0026#34;; } } %\u0026gt; \u0026lt;% try { //避免重新建立连接而丢弃前面步骤 if (!status) { Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); connection = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123\u0026#34;); statement = connection.createStatement(); status = true; } } catch (Exception e) { e.printStackTrace(); } %\u0026gt; \u0026lt;div style=\u0026#34;text-align: center\u0026#34;\u0026gt; \u0026lt;% //结果输出 sql_input = request.getParameter(\u0026#34;SQL_statement\u0026#34;); if (sql_input != null) { Object rt = process(sql_input); if (rt instanceof String) { out.print(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + rt.toString() + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;); } else if (rt instanceof Integer) { out.print(\u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + \u0026#34;Query OK. \u0026#34; + rt + \u0026#34; effected.\u0026#34; + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34;); } else { ResultSet rs = (ResultSet) rt; ResultSetMetaData rsmd = rs.getMetaData(); out.println(\u0026#34;\u0026lt;table align=\\\u0026#34;center\\\u0026#34; border=\\\u0026#34;1\\\u0026#34;\u0026gt;\u0026#34;); out.println(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (int i = 1; i \u0026lt;= rsmd.getColumnCount(); ++i) out.println(\u0026#34;\u0026lt;th\u0026gt;\u0026#34; + rsmd.getColumnName(i) + \u0026#34;\u0026lt;/th\u0026gt;\u0026#34;); out.println(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); while (rs.next()) { out.println(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (int i = 1; i \u0026lt;= rsmd.getColumnCount(); ++i) out.println(\u0026#34;\u0026lt;td\u0026gt;\u0026#34; + rs.getString(i) + \u0026#34;\u0026lt;/td\u0026gt;\u0026#34;); out.println(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); } out.println(\u0026#34;\u0026lt;/table\u0026gt;\u0026#34;); } } %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/html\u0026gt; 一个额外的问题\r如果不能对jsp文件进行test，三角形标符不能使用，\n使用要配置Tomcat服务器，如图点击进去 点加号 +，找到Tomcat Server目录下的local 点击 在 Desployment 中点加号+ ，就可以添加选择项目了\n点击ok就配置成功了，这样就可以test了\n","date":"2024-09-01T23:37:54+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/jsp/","title":"JSP 简单入门与 IDEA 开发环境配置"},{"content":"Tomcat安装及配置\r安装\r网址：Tomcat官网\n选择版本：点击左边Download下的which version，根据Supported Java Versions来选择合适的Tomcat版本\nTomcat官网首页\n下载软件：点击左边Download下的具体版本，如：Tomcat 9。滑动至页面底部，在Core区域根据windows版本进行选择。\n配置\r配置Tomcat环境变量前一定要配置好java的环境变量，尤其是JAVA_HOME\n以下环境变量均在系统环境变量中设置。\n新建 CATALINA_HOME 环境变量，变量：CATALINA_HOME 值：D:\\DevelopmentTool\\apache-tomcat-9.0.43\n修改 Path ，在 Path 后添加(新建)：%CATALINA_HOME%\\lib、%CATALINA_HOME%\\bin、%CATALINA_HOME%\\lib\\servlet-api.jar环境变量中，环境变量名对大小写不敏感，可将CATALINA_HOME小写，但需要保持一致.\n注意：在环境变量中，如果新建有两个相同仅大小写不同的的变量名，会覆盖设置。如：path和PATH\nTomcat文件目录\rbin：可执行文件（启动文件startup.bat、关闭文件shutdown.bat）\nconf：配置文件（修改端口号：server.xml，建议将server.xml备份）\nlib：依赖的jar包\nlog：日志文件（记录出错等信息）\ntemp：临时文件\nwebapps：可执行的项目。默认作为存放开发项目的目录\nwork：存放由jsp翻译成的.java源文件,以及编译的.class字节码文件(jsp -\u0026gt;java -\u0026gt;class)\n启动Tomcat\r方法一：在.\\apache-tomcat-9.0.43\\bin目录下，双击startup.bat打开窗口，双击 shutdown.bat关闭窗口。\n如果点startup.bat窗口的×直接关闭，可能会造成关闭异常\n方法二：通过命令行窗口打开。cmd命令cd到.\\apache-tomcat-9.0.43\\bin，然后输入命令：startup，出现对话框，表明服务启动成功。\n常见问题\r闪退\r可能原因是：环境变量配置不正确\nJAVA_HOME中的路径不能用分号结尾，如C:\\Program Files\\Java\\jdk1.8.0_121\nJAVA_HOME的路径是JDK路径，而不是JRE的路径。\nCATALINA_HOME中的路径不能以\\结尾。\n在环境变量中修改添加变量时，一定要注意分号、空格，是否有多余的字母。\n乱码\r问题描述：打开startup.bat后汉字乱码\n解决方法：在.\\apache-tomcat-9.0.43\\conf下打开logging.properties文件\n将java.util.logging.ConsoleHandler.encoding = UTF-8\n替换为java.util.logging.ConsoleHandler.encoding = GBK\nTomcat乱码\r符号乱码\r在我配置过程中出现了符号类型的乱码，使用SET JAVA_OPTS=-Duser.language=en -Duser.country=US将运行语言强制转换为英文可完美解决\n与其他服务的端口号冲突\rtomcat端口号默认8080，如果和其他服务的端口号冲突，则可对端口号进行修改\n在.\\apache-tomcat-9.0.43\\conf下打开server.xml文件，在文件的69行左右，将port=\u0026ldquo;8080\u0026quot;修改为指定的某一端口号，重新启动。\n\u0026lt;Connector port=\u0026quot;8080\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; connectionTimeout=\u0026quot;20000\u0026quot; redirectPort=\u0026quot;8443\u0026quot; /\u0026gt; 访问Tomcat\r先打开startup.bat，再打开浏览器，在地址栏中输入http://localhost:8080或localhost:8080回车，如果看到Tomcat自带的一个JSP页面，说明JDK和Tomcat已搭建成功。\nhttp://localhost:8080是完整形式，但大多数浏览器会自动添加前面的’http://’ 浏览器中访问Tomcat，此页面在webapps文件中，默认为ROOT文件夹\n无法在浏览器中访问Tomcat\r检查./bin目录下startup.bat是否启动成功\n检查端口号是否正确\n更换浏览器重新访问\n检查环境变量是否正确\n常见状态码\r200：一切正常\n300/301：页面重定向 （跳转）\n404：资源不存在\n403：权限不足 （如果访问a目录，但是a目录设置 不可见）\n500：服务器内部错误（代码有误）\n卸载Tomcat\r直接删除Tomcat目录，并删除已配置的环境变量\n解决Tomcat运行startup.bat 闪退问题\rTomcat 解压完成之后, 执行批处理文件startup.bat, 一直闪退, 网络上的大多数都是配置环境变量, 确定端口号是否被占用等\n但是实际上环境变量与端口号都没有问题却依然闪退, 此时可以在startup.bat文件的头部添加JDK安装根目录和Tomcat所在根目录:\nJAVA_HOME``TOMCAT_HOME\n根据个人的路径添加如下: SET JAVA_HOME=E:\\java\\JDK, SET TOMCAT_HOME=E:\\java\\apache-tomcat-9.0.84\n要放在@echo off前面\n之后双击运行, 顺利启动:\n网站当然也可以正常进入:\n如果shutdown.bat执行也有闪退的问题, 解决方式与上面一直即可\n","date":"2024-09-01T18:21:40+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/tomcat/","title":"Tomcat安装与问题解决"},{"content":"多线程与多进程\r一, 什么是进程, 什么是线程?\r​\t进程: 运行中的程序. 每次我们执行一个程序, 咱们的操作系统对自动的为这个程序准备一些必要的资源(例如, 分配内存, 创建一个能够执行的线程. )\n​\t线程: 程序内, 可以直接被CPU调度的执行过程. 是操作系统能够进行运算调度的最小单位. 它被包含在进程之中, 是进程中的实际运作单位.\n​\t进程与线程之间的关系:\n​\t进程是资源单位(公司). 线程是执行单位(员工). 就好比是一家公司. 一家公司的资源就是桌椅板凳, 电脑饮水机这些资源, 但是, 我们如果说一家公司正在运转着, 运行着. 那里面必须要有能为这家公司工作的人. 程序里面也一样, 进程就是为了程序运行而需要的各种资源. 但是程序想要运行, 就必须由线程来被CPU调度执行.\n​\t运行的每一个程序默认都会有一个线程. 哪怕是只有helloworld级别的程序. 想要执行. 也会有一个线程产生.\n如何提高一家公司的产能效率\n二, 多线程\r​\t顾名思义, 多线程就是让程序产生多个线程一起去执行. 还拿公司举例子. 一家公司里如果只有一个员工, 工作效率肯定不会高到哪里去. 怎么提高效率? 多招点儿人就OK了.\n1. 直接用Thread创建线程\r我们先看看单线程的效果\n1 2 3 4 5 6 7 8 9 def func(): for i in range(1000): print(\u0026#34;func\u0026#34;, i) if __name__ == \u0026#39;__main__\u0026#39;: func() for i in range(1000): print(\u0026#34;main\u0026#34;, i) 再看多线程\n1 2 3 4 5 6 7 8 9 10 11 12 13 from threading import Thread def func(): for i in range(1000): print(\u0026#34;func\u0026#34;, i) if __name__ == \u0026#39;__main__\u0026#39;: t = Thread(target=func) t.start() for i in range(1000): print(\u0026#34;main\u0026#34;, i) 2. 线程池\rpython还提供了线程池功能. 可以一次性的创建多个线程, 并且, 不需要我们程序员手动去维护. 一切都交给线程池来自动管理.\n1 2 3 4 5 6 7 8 9 10 # 线程池 def fn(name): for i in range(1000): print(name, i) if __name__ == \u0026#39;__main__\u0026#39;: with ThreadPoolExecutor(10) as t: for i in range(100): t.submit(fn, name=f\u0026#34;线程{i}\u0026#34;) 如果任务有返回值怎么办?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def func(name): time.sleep(2) return name def do_callback(res): print(res.result()) if __name__ == \u0026#39;__main__\u0026#39;: with ThreadPoolExecutor(10) as t: names = [\u0026#34;线程1\u0026#34;, \u0026#34;线程2\u0026#34;, \u0026#34;线程3\u0026#34;] for name in names: # 方案一, 添加回调 t.submit(func, name).add_done_callback(do_callback) if __name__ == \u0026#39;__main__\u0026#39;: start = time.time() with ThreadPoolExecutor(10) as t: names = [5, 2, 3] # 方案二, 直接用map进行任务分发. 最后统一返回结果 results = t.map(func, names) # 结果是按照你传递的顺序来执行的, 代价就是如果第一个没结束. 后面就都没结果 for r in results: print(\u0026#34;result\u0026#34;, r) print(time.time() - start) 3. 多线程在爬虫中的应用\rhttp://www.boxofficecn.com/boxofficecn\n我们抓取从1994年到2021年的电影票房.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import requests from lxml import etree from concurrent.futures import ThreadPoolExecutor def get_page_source(url): resp = requests.get(url) resp.encoding = \u0026#39;utf-8\u0026#39; return resp.text def parse_html(html): try: tree = etree.HTML(html) trs = tree.xpath(\u0026#34;//table/tbody/tr\u0026#34;)[1:] result = [] for tr in trs: year = tr.xpath(\u0026#34;./td[2]//text()\u0026#34;) year = year[0] if year else \u0026#34;\u0026#34; name = tr.xpath(\u0026#34;./td[3]//text()\u0026#34;) name = name[0] if name else \u0026#34;\u0026#34; money = tr.xpath(\u0026#34;./td[4]//text()\u0026#34;) money = money[0] if money else \u0026#34;\u0026#34; d = (year, name, money) if any(d): result.append(d) return result except Exception as e: print(e) # 调bug专用 def download_one(url, f): page_source = get_page_source(url) data = parse_html(page_source) for item in data: f.write(\u0026#34;,\u0026#34;.join(item)) f.write(\u0026#34;\\n\u0026#34;) def main(): f = open(\u0026#34;movie.csv\u0026#34;, mode=\u0026#34;w\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;) lst = [str(i) for i in range(1994, 2022)] with ThreadPoolExecutor(10) as t: # 方案一 # for year in lst: # url = f\u0026#34;http://www.boxofficecn.com/boxoffice{year}\u0026#34; # # download_one(url, f) # t.submit(download_one, url, f) # 方案二 t.map(download_one, (f\u0026#34;http://www.boxofficecn.com/boxoffice{year}\u0026#34; for year in lst), (f for i in range(len(lst)))) if __name__ == \u0026#39;__main__\u0026#39;: main() 三, 多进程\r一个公司能创造的价值毕竟是有限的. 怎么办? 开分公司啊. 此所谓多进程. python实现多进程的方案和多线程几乎一样. 非常的简单\n1. 直接用Process创建进程\r1 2 3 4 5 6 7 8 9 10 11 def func(): for i in range(1000): print(\u0026#34;func\u0026#34;, i) if __name__ == \u0026#39;__main__\u0026#39;: p = Process(target=func) p.start() for i in range(1000): print(\u0026#34;main\u0026#34;, i) 2. 多进程在爬虫中的应用\r​\t如果遇到图片抓取的时候, 我们知道图片在一般都在网页的img标签中src属性存放的是图片的下载地址. 此时我们可以采用多进程的方案来实现, 一个负责疯狂扫图片下载地址. 另一个进程只负责下载图片.\n​\t综上, 多个任务需要并行执行, 但是任务之间相对独立(不一定完全独立). 可以考虑用多进程.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from multiprocessing import Process,Queue from concurrent.futures import ThreadPoolExecutor from lxml import etree import requests headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36\u0026#34; } def get_img_src(q): \u0026#34;\u0026#34;\u0026#34; 进程1: 负责提取页面中所有的img的下载地址 将图片的下载地址通过队列. 传输给另一个进程进行下载 \u0026#34;\u0026#34;\u0026#34; for i in range(1, 11): url = f\u0026#34;https://www.pkdoutu.com/photo/list/?page={i}\u0026#34; resp = requests.get(url, headers=headers) tree = etree.HTML(resp.text) srcs = tree.xpath(\u0026#34;//li[@class=\u0026#39;list-group-item\u0026#39;]//img[@referrerpolicy=\u0026#39;no-referrer\u0026#39;]/@data-original\u0026#34;) for src in srcs: q.put(src.strip()) resp.close() q.put(\u0026#34;ok\u0026#34;) def download_img(q): \u0026#34;\u0026#34;\u0026#34; 进程2: 将图片的下载地址从队列中提取出来. 进行下载. \u0026#34;\u0026#34;\u0026#34; with ThreadPoolExecutor(20) as t: while 1: s = q.get() if s == \u0026#39;ok\u0026#39;: break t.submit(donwload_one, s) def donwload_one(s): # 单纯的下载功能 resp = requests.get(s, headers=headers) file_name = s.split(\u0026#34;/\u0026#34;)[-1] # 请提前创建好img文件夹 with open(f\u0026#34;img/{file_name}\u0026#34;, mode=\u0026#34;wb\u0026#34;) as f: f.write(resp.content) print(\u0026#34;一张图片下载完毕\u0026#34;, file_name) resp.close() if __name__ == \u0026#39;__main__\u0026#39;: q = Queue() # 两个进程必须使用同一个队列. 否则数据传输不了 p1 = Process(target=get_img_src, args=(q,)) p2 = Process(target=download_img, args=(q,)) p1.start() p2.start() 记住一个事情就好. 多进程相当于多个程序. 多线程相当于在一个程序里多条任务同时执行.\n","date":"2024-08-28T14:22:47+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/","title":"多线程与多进程"},{"content":"re模块\r在python程序中使用正则呢需要借助re模块\nfindall 查找所有. 返回list\n1 2 3 4 lst = re.findall(\u0026#34;m\u0026#34;, \u0026#34;mai le fo len, mai ni mei!\u0026#34;) print(lst) # [\u0026#39;m\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;m\u0026#39;] lst = re.findall(r\u0026#34;\\d+\u0026#34;, \u0026#34;5点之前. 你要给我5000万\u0026#34;) print(lst) # [\u0026#39;5\u0026#39;, \u0026#39;5000\u0026#39;] search 会进行匹配. 但是如果匹配到了第一个结果. 就会返回这个结果. 如果匹配不上search返回的则是None\n1 2 ret = re.search(r\u0026#39;\\d\u0026#39;, \u0026#39;5点之前. 你要给我5000万\u0026#39;).group() print(ret) # 5 match 只能从字符串的开头进行匹配\n1 2 ret = re.match(\u0026#39;a\u0026#39;, \u0026#39;abc\u0026#39;).group() print(ret) # a finditer 和findall差不多. 只不过这时返回的是迭代器(重点)\n1 2 3 it = re.finditer(\u0026#34;m\u0026#34;, \u0026#34;mai le fo len, mai ni mei!\u0026#34;) for el in it: print(el.group()) # 依然需要分组 compile() 可以将一个长长的正则进行预加载. 方便后面的使用\n1 2 3 obj = re.compile(r\u0026#39;\\d{3}\u0026#39;) # 将正则表达式编译成为一个 正则表达式对象, 规则要匹配的是3个数字 ret = obj.search(\u0026#39;abc123eeee\u0026#39;) # 正则表达式对象调用search, 参数为待匹配的字符串 print(ret.group()) # 结果: 123 正则中的内容如何单独提取?\n单独获取到正则中的具体内容可以给分组起名字\n1 2 3 4 5 6 7 8 9 s = \u0026#34;\u0026#34;\u0026#34; \u0026lt;div class=\u0026#39;西游记\u0026#39;\u0026gt;\u0026lt;span id=\u0026#39;10010\u0026#39;\u0026gt;中国联通\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026#34;\u0026#34;\u0026#34; obj = re.compile(r\u0026#34;\u0026lt;span id=\u0026#39;(?P\u0026lt;id\u0026gt;\\d+)\u0026#39;\u0026gt;(?P\u0026lt;name\u0026gt;\\w+)\u0026lt;/span\u0026gt;\u0026#34;, re.S) result = obj.search(s) print(result.group()) # 结果: \u0026lt;span id=\u0026#39;10010\u0026#39;\u0026gt;中国联通\u0026lt;/span\u0026gt; print(result.group(\u0026#34;id\u0026#34;)) # 结果: 10010 # 获取id组的内容 print(result.group(\u0026#34;name\u0026#34;)) # 结果: 中国联通 # 获取name组的内容 在正则表达式中，?P是一个命名捕获组的语法，它用于给捕获组命名，以便于之后可以通过名字来引用匹配到的文本。这里的各个部分含义如下：\n?P：这是命名捕获组的开始标记，告诉正则表达式解析器接下来的内容是一个命名捕获组。\n：这是捕获组的名称，你可以自定义一个有意义的名字。这个名字在匹配后的操作中用来引用这个捕获组匹配到的文本。\n使用命名捕获组的好处是，代码可读性更强，也更容易理解每个捕获组的作用，特别是在处理复杂的正则表达式时。在Python的re模块中，一旦命名捕获组匹配成功，你可以使用group()方法并传入捕获组的名字来获取相应的匹配文本。\n正则表达式本身是用来提取字符串中的内容的. 也可以用作字符串的替换\n1 2 3 4 5 6 import re r = re.split(r\u0026#34;\\d+\u0026#34;, \u0026#34;我今年19岁了, 你知道么, 19岁就已经很大了. 周杰伦20岁就得奖了\u0026#34;) print(r) # [\u0026#39;我今年\u0026#39;, \u0026#39;岁了, 你知道么, \u0026#39;, \u0026#39;岁就已经很大了. 周杰伦\u0026#39;, \u0026#39;岁就得奖了\u0026#39;] # 替换 r = re.sub(r\u0026#34;\\d+\u0026#34;, \u0026#34;18\u0026#34;, \u0026#34;我今年19岁了, 你知道么, 19岁就已经很大了. 周杰伦20岁就得奖了\u0026#34;) print(r) # 我今年18岁了, 你知道么, 18岁就已经很大了. 周杰伦18岁就得奖了 ​\t哦了. 正则. 这些东西够用了.\n","date":"2024-08-26T15:14:42+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式"},{"content":"原文\r约翰·罗伯茨 ｜ 现任美国首席大法官\r约翰·罗伯茨，2005年9月由小布什总统提名，参议院批准通过，就任美国联邦最高法院的第17任首席大法官，是美国两个世纪以来最年轻的首席大法官。\r“人们唯有遭遇不公时，才知道公正的价值”，约翰·罗伯茨大法官，在他儿子初中毕业典礼上的致辞，引起美国社交平台上刷屏并讨论。\r#####《华盛顿邮报》在评论中说：“罗伯茨大法官本年度最好的作品，不是某个案子的判决书，而是在儿子毕业典礼上的致辞。”\nRain, somebody said, is like confetti from heaven. So even the heavens are celebrating this morning, joining the rest of us at this wonderful commencement ceremony.\nBefore we go any further, graduates, you have an important task to perform because behind you are your parents and guardians. Two or three or four years ago, they drove into Cardigan, dropped you off, helped you get settled and then turned around and drove back out the gates. It was an extraordinary sacrifice for them. They drove down the trail of tears back to an emptier and lonelier house. They did that because the decision about your education, they knew, was about you. It was not about them. That sacrifice and others they made have brought you to this point. But this morning is not just about you. It is also about them, so I hope you will stand up and turn around and give them a great round of applause. Please.\nNow when somebody asks me how the remarks at Cardigan went, I will be able to say they were interrupted by applause. Congratulations, class of 2017. You’ve reached an important milestone. An important stage of your life is behind you. I’m sorry to be the one to tell you it is the easiest stage of your life, but it is in the books. While you’ve been at Cardigan, you have all been a part of an important international community as well. And I think that needs to be particularly recognized.\n[Roberts gave brief remarks in other languages.]\nNow around the country today at colleges, high schools, middle schools, commencement speakers are standing before impatient graduates. And they are almost always saying the same things. They will say that today is a commencement exercise. ‘It is a beginning, not an end. You should look forward.’ And I think that is true enough, however, I think if you’re going to look forward to figure out where you’re going, it’s good to know where you’ve been and to look back as well. And I think if you look back to your first afternoon here at Cardigan, perhaps you will recall that you were lonely. Perhaps you will recall that you were a little scared, a little anxious. And now look at you. You are surrounded by friends that you call brothers, and you are confident in facing the next step in your education.\nIt is worth trying to think why that is so. And when you do, I think you may appreciate that it was because of the support of your classmates in the classroom, on the athletic field and in the dorms. And as far as the confidence goes, I think you will appreciate that it is not because you succeeded at everything you did, but because with the help of your friends, you were not afraid to fail. And if you did fail, you got up and tried again. And if you failed again, you got up and tried again. And if you failed again, it might be time to think about doing something else. But it was not just success, but not being afraid to fail that brought you to this point.\nNow the commencement speakers will typically also wish you good luck and extend good wishes to you.\n通常，毕业典礼的演讲嘉宾都会祝你们好运并送上祝福。\nI will not do that, and I’ll tell you why.\n但我不会这样做，让我来告诉你为什么。\nFrom time to time in the years to come, I hope you will be treated unfairly, so that you will come to know the value of justice.\n在未来的很多年中，我希望你被不公正地对待过，唯有如此，你才真正懂得公正的价值。\nI hope that you will suffer betrayal because that will teach you the importance of loyalty.\n我希望你遭受背叛，唯有如此，你才领悟到忠诚之重要。\nSorry to say, but I hope you will be lonely from time to time so that you don’t take friends for granted.\n很抱歉，我会祝福你时常感到孤独，唯有如此，你才不会把良朋益友视为人生中的理所当然。\nI wish you bad luck, again, from time to time so that you will be conscious of the role of chance in life and understand that your success is not completely deserved and that the failure of others is not completely deserved either.\n我祝福你人生旅途中时常运气不佳，唯有如此，你才意识到概率和机遇在人生中扮演的角色，\n进而理解你的成功并不完全是命中注定，而别人的失败也不是天经地义。\nAnd when you lose, as you will from time to time, I hope every now and then, your opponent will gloat over your failure. It is a way for you to understand the importance of sportsmanship.\n当你失败的时候，时不时地，我希望你的对手会因为你的失败而幸灾乐祸，\n唯有如此，才能让你意识到有风度的竞争精神之重要。\nI hope you’ll be ignored so you know the importance of listening to others,\n我祝福你会被忽视，唯有如此，你才会意识到倾听他人的重要性。\nand I hope you will have just enough pain to learn compassion.\n我祝福你遭受切肤之痛，唯有如此，才能让你感同身受，从而对别人有同情的理解。\nWhether I wish these things or not, they’re going to happen.\n无论我是否送上这些“祝福”，这些都将在生命中必然发生。\nAnd whether you benefit from them or not will depend upon your ability to see the message in your misfortunes.\n而你能否从中获益，取决于你是否能从你的不幸中领悟到想要传递给你的信息。\nNow commencement speakers are also expected to give some advice. They give grand advice, and they give some useful tips. The most common grand advice they give is for you to be yourself.\n毕业典礼的致辞者习惯给出很多建议。……最常见的建议是“做自己”。\nIt is an odd piece of advice to give people dressed identically, but you should — you should be yourself. But you should understand what that means. Unless you are perfect, it does not mean don’t make any changes. In a certain sense, you should not be yourself. You should try to become something better.\n但你得明白其中真意。如果你并非足够完美，就必须作出改变。这时，你就不能光想着做自己，必须不断自我完善。\nPeople say ‘be yourself’ because they want you to resist the impulse to conform to what others want you to be. But you can’t be yourself if you don’t learn who are, and you can’t learn who you are unless you think about it.\n别人说“做自己”，是希望你抵制按他人意愿随波逐流的冲动。但如果连你都不知道自己要成为什么样的人，是不可能“做自己”的，而如果不思考这些，你也不可能知道自己想成为什么样的人。\nThe Greek philosopher Socrates said, ‘The unexamined life is not worth living.’ And while ‘just do it’ might be a good motto for some things, it’s not a good motto when it’s trying to figure out how to live your life that is before you. And one important clue to living a good life is to not to try to live the good life. The best way to lose the values that are central to who you are is frankly not to think about them at all. So that’s the deep advice.\n希腊哲人苏格拉底说过，“未经自省的人生没有意义。”对某些事情而言，“just do it ”是不错的座右铭，但在你想明白自己想要什么样的人生之前，这个座右铭可不咋滴。\nNow some tips as you get ready to go to your new school. Other the last couple of years, I have gotten to know many of you young men pretty well, and I know you are good guys. But you are also privileged young men. And if you weren’t privileged when you came here, you are privileged now because you have been here. My advice is: Don’t act like it. When you get to your new school, walk up and introduce yourself to the person who is raking the leaves, shoveling the snow or emptying the trash. Learn their name and call them by their name during your time at the school.\nAnother piece of advice: When you pass by people you don’t recognize on the walks, smile, look them in the eye and say hello. The worst thing that will happen is that you will become known as the young man who smiles and says hello, and that is not a bad thing to start with.You’ve been at a school with just boys. Most of you will be going to a school with girls. I have no advice for you. The last bit of advice I’ll give you is very simple, but I think it could make a big difference in your life. Once a week, you should write a note to someone. Not an email. A note on a piece of paper. It will take you exactly 10 minutes. Talk to an adult, let them tell you what a stamp is. You can put the stamp on the envelope. Again, 10 minutes, once a week. I will help you, right now. I will dictate to you the first note you should write. It will say, ‘Dear [fill in the name of a teacher at Cardigan Mountain School].’ Say: ‘I have started at this new school. We are reading [blank] in English. Football or soccer practice is hard, but I’m enjoying it. Thank you for teaching me.’ Put it in an envelope, put a stamp on it and send it. It will mean a great deal to people who — for reasons most of us cannot contemplate — have dedicated themselves to teaching middle school boys. As I said, that will take you exactly 10 minutes a week. By the end of the school year, you will have sent notes to 40 people. Forty people will feel a little more special because you did, and they will think you are very special because of what you did. No one else is going to carry that dividend during your time at school.\nEnough advice. I would like to end by reading some important lyrics. I cited the Greek philosopher Socrates earlier. These lyrics are from the great American philosopher, Bob Dylan. They’re almost 50 years old. He wrote them for his son, Jesse, who he was missing while he was on tour. It lists the hopes that a parent might have for a son and for a daughter. They’re also good goals for a son and a daughter. The wishes are beautiful, they’re timeless. They’re universal. They’re good and true, except for one: It is the wish that gives the song its title and its refrain. That wish is a parent’s lament. It’s not a good wish.\nSo these are the lyrics from Forever Young by Bob Dylan:\nMay God bless you and keep you always\n愿上帝庇佑，护你前路；\nMay your wishes all come true\n愿你美梦均可成真；\nMay you always do for others And let others do for you\n愿你与人为善，相互扶持；\nMay you build a ladder to the stars And climb on every rung\n愿你建成通往群星的天梯；稳妥沿它而上；\nAnd may you stay forever young\n愿你永远年轻；\nMay you grow up to be righteous\n愿你成为正直之人；\nMay you grow up to be true\n愿你成就真实自我；\nMay you always know the truth And see the lights surrounding you\n愿你永远感知真理，看向身边无尽光明；\nMay you always be courageous Stand upright and be strong\n愿你勇敢无惧，坚强可靠；\nAnd may you stay forever young\n愿你永远年轻,拥有纯洁之心；\nMay your hands always be busy May your feet always be swift\n愿你双手永远忙碌，愿你脚步永远轻盈；\nMay you have a strong foundation When the winds of changes shift\n在变故横生之时，愿你根基牢靠；\nMay your heart always be joyful May your song always be sung\n愿你心中永远充满快乐，愿你的歌声永远嘹亮；\nAnd may you stay forever young.\n愿你永远年轻。”\nThank you.\n思考\r人生本就是一场逐光的旅行，但是如飞蛾一般的身体，总是不可避免地遭受各种的磨难与苦痛。\n我们应该学会倾听，珍惜友谊，重视公平，对人忠诚，所谓己所不欲，勿施于人。被强行加诸于自己的痛苦，这终归是只有自己才能品尝的酒，醇香且灼烈。\n","date":"2024-08-19T10:19:28+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E6%94%B6%E9%9B%86/","title":"愿你成才的路上铺满荆棘"},{"content":"思考\r最近几日尝试在网上寻找了一下实习岗位，怎么说呢，简历也是写的七零八落，总归是不让自己满意。\n但是看下来市场并不是完全无情的，我仍然是有机会的，自己先前的技术栈虽然是零零碎碎，但好坏是可以写出来一点东西，不至于完全虚度光阴。\n接下来打算完善前端的学习，掌握几种基本的框架，在我看来前端就是画框框，画框框嘛，这有什么难的😊\n有的人说要下注下一代互联网技术，我其实也很早就接触到了，不过一直没有深入，以为我认为那种技术很难被社会包容，难以得到认可，不过既然近几日又被我看到了，那就试试吧，毕竟谁也不知道未来会怎么样。\n总结\r还是要继续走下去呀，谁知道未来会变成什么样子，不过既然心里的目标已经变得更加清晰了，那么自己一定可以到达那个地方，加油加油加油！\n","date":"2024-08-01T22:04:11+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/offer/","title":"网投实习心得"},{"content":"前言\r在Hugo上写文章的时候，肯定会遇到要插入图片的情况。\n在content/post目录下的markdown文件里引用图片，让网站能正常显示图片。\n这里我们其实有2种选择：\n使用图床：图床其实就是图片存储空间，我们可以把要插入在markdown的图片先上传到图床里，生成图片的永久链接，然后在markdown里引用这个图片链接即可。 优点：文章可以不用修改，直接复制到多个平台，而不用担心图片加载会出问题，因为图片链接是固定永久的。 缺点：免费的图床有上传数量和容量限制，还可能停用。付费的图床嘛，有钱就可以任性。。。\n使用本地图片：直接在markdown里引用本地的图片 优点：免费，图片和文章在一起，不用担心图片丢失 缺点：文章复制到其它平台的时候，对于图片的引用要手工修改，比较繁琐 这篇文章主要讲下如何基于Hugo，在文章对应的markdown文件里引用本地图片。\n操作\r我们先讲下Hugo的一个实现逻辑：\nHugo博客的根目录有一个static目录，这个static目录就是用来存放一些静态文件，比如图片、css、js文件等。\n执行hugo命令的时候，会把static目录下的子目录或文件复制到public目录下。比如我在static下添加了一个img子目录，并且在img子目录放了图片，那执行hugo命令后，就会把static\\img文件的内容拷贝到public\\img里面。\n大家都知道Hugo博客网站展示的其实是public下的内容，因此markdown文章里引用图片的时候，得引用pubic下的图片才可以。\n具体操作非常简单，分2步：\n在static目录下创建img子目录，把markdown要使用的图片放在static\\img目录里。\n在markdown文件里，按照如下格式引用图片(这里假设图片名称叫wechat.png)。这样最终public目录下生成的静态页面就可以引用到public\\img下的图片了。\nmarkdown ![](/img/wechat.png)\n","date":"2024-07-21T09:01:59+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","title":"博客插入图片"},{"content":"前言\r本篇博文主要记录本 Hugo 博客从 0 到 1 的简要步骤，但其适用于其他大多数 hugo 博客的搭建流程，仅仅区别于主题的不同。\n具体流程\r准备Hugo文件\r下载 hugo 文件（extended 扩展版）并解压到自定义文件夹（例：我存放的目录为D:\\Hugo\\bin）\n配置环境变量\r在 我的电脑 --\u0026gt; 属性 --\u0026gt; 高级系统设置 --\u0026gt; 环境变量 --\u0026gt; 系统变量 --\u0026gt; Path 中增加一条D:\\Hugo\\bin，即解压后的 hugo.exe 文件存放的目录。\nD:\\Hugo\\bin 修改为自己对应文件位置路径\n检查版本\r打开 cmd 终端执行以下命令查看是否安装成功（是否输出 Hugo 版本信息）\n1 hugo version 生成博客\r生成博客\r打开命令窗口，进入D:\\Hugo\\Sites文件夹（生成站点的文件夹，自定义），输入命令\n1 hugo new site myblog 命令执行完成之后在D:\\Hugo\\Sites\\myblog文件夹下会自动生成博客需要的文件\n安装主题\rhugo 主题网站\n执行以下命令完成 meme 主题的安装。\n1 2 3 cd myblog git init git submodule add --depth 1 https://github.com/reuixiy/hugo-theme.git themes/hugo-theme 开始写作\r将 config.toml 替换为示例配置。\n1 rm config.toml \u0026amp;\u0026amp; cp themes/hugo-theme/config-examples/zh-cn/config.toml config.toml 新建一篇文章和一个关于页面：\n1 hugo new \u0026#34;posts/ 1 hugo new \u0026#34;about/_index.md\u0026#34; 本地预览\r1 hugo server -t meme --buildDrafts 1 hugo server -D 准备个人 GitHub 账号\r创建个人 GitHub 账号与仓库（命名：账号名.github.io）\n部署到 GitHub\r1 hugo --theme=meme --baseUrl=\u0026#34;https://username.github.io/\u0026#34; --buildDrafts 在当前myblog文件夹下会生成 public 文件夹\n接着将 public 文件夹上传至 GitHub 仓库\n1 2 3 4 5 6 cd public git init git add . git commit -m \u0026#39;model：博客第一次提交\u0026#39; git remote add origin https://github.com/username/username.github.io.git git push -u origin master 在线访问网站\r访问网址：username.github.io\n","date":"2024-07-20T22:57:40+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/","title":"博客搭建过程"},{"content":"1.辗转反侧\r1.1 相见\r最开始了解到一个个人博客，大概是看到了某个人的作品，当时惊叹于这种对当时的我来说是一种巨大打击的作品，我接触互联网还是10年左右，当时各种各样的东西在网络上方兴未已。要我说，当时的互联网，还是一个人人都可以得到他人近乎无私帮助的时代。\n1.2 历程\r好了，既然了解了，那就开干吧，但是当时还没有这种意识，当我真正有一个成熟的想法时，这已经是十年之后了。\n1.3 准备\r最开始，我还相信互联网依旧是可以随便找到自己所需要的东西的时代，当我再次满怀期待的开始着手进行，我这才发现，这互联网，已经不再是记忆中那般摸样了。\n2.开始\r2.1 类型之分\r市面上常规的博客大致分为静态与动态两个大类，其中动态依托于云服务器运行，这样再搭配宝塔面板等生成工具可以非常方便的完成个人博客的搭建，这可以说是近乎完美的，但是这种方法每年都需要向运营商支付高昂的费用。因此，这段然不在我的考虑范围之内，我选择了搭建静态博客，这可以为我省下大量的费用，近乎可以说是零成本的，但缺点就是，这个环节中出现某些问题，往往是致命的。\n2.2 做\r既然是自己的梦想，那就不要耽搁了，于是我开始在网上查阅各种资料来进行准备，最终选择了hexo框架来进行搭建，但我在最开始就遇到了困难，bash、node.js这两个工具让我焦头烂耳，是的，在最初安装时工具的各方面调试就让我难以招架，甚至工作一度因为此种原因而搁置*** 如今，当我已经完成之后，回首望去，自己对当时的问题感到十分不解，细细想来，当时应该是环境变量配置出现问题，当时各种教程给的方法众说纷纭，自己对未知的恐惧一度让种子死亡在泥土里。\n2.3 末\r当然，现在看来，自己是走了很多捷径才能够完成，其中许多机理，我在书写这篇文章时依旧不是太明白，不过，这些问题还是被克服了，总之结果是美好的。\n3.😊❤️\r在这个过程中，我虽然遇到了一些错误的指引，不过最终还是可以找到正确的方案，在此期间，相当量的教程给予了我很大的帮助，或许，那种乐于分享的火焰依然有人传承下去。我很感谢互联网的存在，这让我看到了广阔的天地（虽然我大多数时间都没干正事），我想大多数如我般的穷人，他们可以一生都会处于一种跟着短视频之类废料行舟的状态，我认为人如果能把自己的空闲时间挪用一小部分在学习上，虽不可谈会有多大的建树，但这一定是对自己及家庭乃至整个社会都有益的事。\n在最后，我要再次感谢那些留些路标的人，他们为我的沙漠行舟提供了巨大的助力，我将会在接下来的日子里将我遇到的困难和解决方法一一书写以供后来者参考，在此，再次感谢那些为我提供帮助的人，因为有你们，这火焰才能越燃越旺。\n","date":"2023-08-31T06:00:00+08:00","image":"https://yaoxiaoxie.github.io/img/face1.jpg","permalink":"https://yaoxiaoxie.github.io/p/%E5%BF%83%E5%BE%97/","title":"这一路の经过~"}]